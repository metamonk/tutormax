#!/usr/bin/env python3
"""
Security Vulnerability Scanner for TutorMax

Automated vulnerability detection and security assessment tool.
Scans for common vulnerabilities including:
- SQL Injection
- XSS (Cross-Site Scripting)
- CSRF vulnerabilities
- Authentication weaknesses
- Insecure configurations
- Dependency vulnerabilities
- Information disclosure

Task: 14.8 - Security Testing & Penetration Testing

Usage:
    python3 scripts/security_vulnerability_scanner.py
    python3 scripts/security_vulnerability_scanner.py --verbose
    python3 scripts/security_vulnerability_scanner.py --export-report
"""

import asyncio
import re
import sys
import json
from typing import List, Dict, Any, Optional
from datetime import datetime
from pathlib import Path
import subprocess

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    import httpx
    from sqlalchemy import select, text
    from sqlalchemy.ext.asyncio import AsyncSession
except ImportError:
    print("Error: Required dependencies not installed")
    print("Install with: pip install httpx sqlalchemy asyncpg")
    sys.exit(1)


class VulnerabilityScanner:
    """Automated security vulnerability scanner."""

    def __init__(self, base_url: str = "http://localhost:8000", verbose: bool = False):
        self.base_url = base_url
        self.verbose = verbose
        self.vulnerabilities: List[Dict[str, Any]] = []
        self.passed_checks: List[str] = []
        self.warnings: List[Dict[str, Any]] = []

    def log(self, message: str, level: str = "INFO"):
        """Log message if verbose mode is enabled."""
        if self.verbose or level in ["ERROR", "CRITICAL", "VULNERABILITY"]:
            timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
            print(f"[{timestamp}] [{level}] {message}")

    def add_vulnerability(
        self,
        severity: str,
        category: str,
        title: str,
        description: str,
        remediation: str,
        **kwargs
    ):
        """Record a security vulnerability."""
        vuln = {
            "severity": severity,  # CRITICAL, HIGH, MEDIUM, LOW
            "category": category,
            "title": title,
            "description": description,
            "remediation": remediation,
            "timestamp": datetime.utcnow().isoformat(),
            **kwargs
        }
        self.vulnerabilities.append(vuln)
        self.log(f"[{severity}] {title}: {description}", level="VULNERABILITY")

    def add_warning(self, category: str, message: str, recommendation: str):
        """Record a security warning (potential issue)."""
        warning = {
            "category": category,
            "message": message,
            "recommendation": recommendation,
            "timestamp": datetime.utcnow().isoformat()
        }
        self.warnings.append(warning)
        self.log(f"[WARNING] {category}: {message}", level="WARNING")

    def add_passed_check(self, check_name: str):
        """Record a passed security check."""
        self.passed_checks.append(check_name)
        self.log(f"✓ Passed: {check_name}", level="INFO")

    async def test_sql_injection(self):
        """Test for SQL injection vulnerabilities."""
        self.log("Testing for SQL injection vulnerabilities...")

        payloads = [
            "' OR '1'='1",
            "1' OR '1'='1' --",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "1; SELECT * FROM users--"
        ]

        endpoints = [
            "/api/students",
            "/api/tutors",
            "/api/sessions",
        ]

        async with httpx.AsyncClient() as client:
            for endpoint in endpoints:
                for payload in payloads:
                    try:
                        # Test query parameters
                        response = await client.get(
                            f"{self.base_url}{endpoint}?id={payload}",
                            timeout=5.0
                        )

                        # Check for SQL error messages in response
                        if any(keyword in response.text.lower() for keyword in [
                            "sql syntax", "mysql", "postgresql", "sqlite",
                            "syntax error", "database error", "pg_"
                        ]):
                            self.add_vulnerability(
                                severity="CRITICAL",
                                category="SQL Injection",
                                title=f"Potential SQL Injection in {endpoint}",
                                description=f"Endpoint may be vulnerable to SQL injection. "
                                           f"SQL error messages detected in response.",
                                remediation="Use parameterized queries and prepared statements. "
                                           "Validate and sanitize all user inputs. "
                                           "Implement input validation middleware.",
                                endpoint=endpoint,
                                payload=payload,
                                response_status=response.status_code
                            )
                        else:
                            # Check if unexpected success (should reject malicious input)
                            if response.status_code == 200:
                                self.add_warning(
                                    category="SQL Injection",
                                    message=f"{endpoint} accepted potentially malicious input",
                                    recommendation="Implement strict input validation"
                                )

                    except httpx.TimeoutException:
                        self.add_warning(
                            category="SQL Injection",
                            message=f"Timeout testing {endpoint} - may indicate query delay attack",
                            recommendation="Review query performance and add timeout limits"
                        )
                    except Exception as e:
                        self.log(f"Error testing {endpoint}: {e}", level="ERROR")

        self.add_passed_check("SQL Injection - No critical vulnerabilities detected")

    async def test_xss_vulnerabilities(self):
        """Test for Cross-Site Scripting (XSS) vulnerabilities."""
        self.log("Testing for XSS vulnerabilities...")

        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "';alert('XSS');//"
        ]

        # Test reflected XSS
        async with httpx.AsyncClient() as client:
            for payload in xss_payloads:
                try:
                    response = await client.get(
                        f"{self.base_url}/api/search?q={payload}",
                        timeout=5.0
                    )

                    # Check if payload is reflected unescaped
                    if payload in response.text:
                        self.add_vulnerability(
                            severity="HIGH",
                            category="Cross-Site Scripting (XSS)",
                            title="Reflected XSS vulnerability detected",
                            description=f"User input is reflected without proper escaping. "
                                       f"Payload: {payload}",
                            remediation="Implement output encoding/escaping. "
                                       "Use Content Security Policy (CSP) headers. "
                                       "Validate and sanitize all user inputs.",
                            payload=payload
                        )

                except Exception as e:
                    self.log(f"Error testing XSS: {e}", level="ERROR")

        self.add_passed_check("XSS - No reflected XSS vulnerabilities detected")

    async def test_csrf_protection(self):
        """Test for CSRF protection."""
        self.log("Testing CSRF protection...")

        async with httpx.AsyncClient() as client:
            # Test state-changing endpoints without CSRF token
            endpoints = [
                ("/api/auth/register", "POST"),
                ("/api/students", "POST"),
                ("/api/sessions", "POST"),
            ]

            for endpoint, method in endpoints:
                try:
                    if method == "POST":
                        response = await client.post(
                            f"{self.base_url}{endpoint}",
                            json={},
                            timeout=5.0
                        )

                        # Should require CSRF token (403 or 400)
                        if response.status_code == 200:
                            self.add_vulnerability(
                                severity="HIGH",
                                category="CSRF",
                                title=f"Missing CSRF protection on {endpoint}",
                                description="Endpoint accepts POST requests without CSRF token validation",
                                remediation="Implement CSRF token validation for all state-changing operations. "
                                           "Enable CSRF middleware in FastAPI.",
                                endpoint=endpoint
                            )
                        elif response.status_code in [403, 400]:
                            # Check if error mentions CSRF
                            if "csrf" in response.text.lower():
                                self.add_passed_check(f"CSRF protection enabled on {endpoint}")

                except Exception as e:
                    self.log(f"Error testing CSRF on {endpoint}: {e}", level="ERROR")

    async def test_authentication_weaknesses(self):
        """Test for authentication vulnerabilities."""
        self.log("Testing authentication security...")

        async with httpx.AsyncClient() as client:
            # Test weak password acceptance
            weak_passwords = ["123456", "password", "abc123", "test"]

            for weak_pwd in weak_passwords:
                try:
                    response = await client.post(
                        f"{self.base_url}/api/auth/register",
                        json={
                            "email": "test@example.com",
                            "password": weak_pwd,
                            "full_name": "Test User"
                        },
                        timeout=5.0
                    )

                    if response.status_code == 200:
                        self.add_vulnerability(
                            severity="MEDIUM",
                            category="Authentication",
                            title="Weak password policy",
                            description=f"System accepts weak passwords like '{weak_pwd}'",
                            remediation="Implement strong password policy: "
                                       "minimum 8 characters, uppercase, lowercase, digits, special chars",
                            weak_password=weak_pwd
                        )
                        break  # Only report once

                except Exception:
                    pass  # Expected to fail

            # Test rate limiting on login
            self.log("Testing rate limiting on authentication...")
            failed_attempts = 0
            for i in range(10):
                try:
                    response = await client.post(
                        f"{self.base_url}/api/auth/login",
                        data={
                            "username": "attacker@example.com",
                            "password": "wrongpassword"
                        },
                        timeout=5.0
                    )

                    if response.status_code == 401:
                        failed_attempts += 1

                    if response.status_code == 429:
                        self.add_passed_check("Rate limiting enabled on login endpoint")
                        break

                except Exception:
                    pass

            if failed_attempts >= 10:
                self.add_vulnerability(
                    severity="HIGH",
                    category="Authentication",
                    title="No rate limiting on login attempts",
                    description="Login endpoint allows unlimited failed attempts (brute force vulnerability)",
                    remediation="Implement rate limiting on authentication endpoints. "
                               "Lock accounts after 5 failed attempts.",
                    failed_attempts=failed_attempts
                )

    async def test_security_headers(self):
        """Test for security headers."""
        self.log("Testing security headers...")

        async with httpx.AsyncClient() as client:
            try:
                response = await client.get(f"{self.base_url}/health", timeout=5.0)

                required_headers = {
                    "X-Content-Type-Options": "nosniff",
                    "X-Frame-Options": "DENY",
                    "Strict-Transport-Security": None,  # HSTS
                    "Content-Security-Policy": None,  # CSP
                    "X-XSS-Protection": "1; mode=block"
                }

                for header, expected_value in required_headers.items():
                    if header not in response.headers:
                        self.add_vulnerability(
                            severity="MEDIUM",
                            category="Security Headers",
                            title=f"Missing security header: {header}",
                            description=f"Response does not include {header} header",
                            remediation=f"Add {header} header to all responses. "
                                       f"Use SecurityHeadersMiddleware in FastAPI.",
                            missing_header=header
                        )
                    elif expected_value and response.headers.get(header) != expected_value:
                        self.add_warning(
                            category="Security Headers",
                            message=f"{header} header value may be incorrect",
                            recommendation=f"Set {header} to '{expected_value}'"
                        )
                    else:
                        self.add_passed_check(f"Security header present: {header}")

            except Exception as e:
                self.log(f"Error testing security headers: {e}", level="ERROR")

    async def test_information_disclosure(self):
        """Test for information disclosure vulnerabilities."""
        self.log("Testing for information disclosure...")

        async with httpx.AsyncClient() as client:
            # Test error messages
            try:
                response = await client.get(
                    f"{self.base_url}/api/nonexistent",
                    timeout=5.0
                )

                # Check for verbose error messages
                sensitive_keywords = [
                    "traceback", "exception", "stack trace",
                    "internal server error", "debug",
                    "/Users/", "/home/", "C:\\", "src/",
                    "database", "password", "secret"
                ]

                for keyword in sensitive_keywords:
                    if keyword.lower() in response.text.lower():
                        self.add_vulnerability(
                            severity="MEDIUM",
                            category="Information Disclosure",
                            title="Verbose error messages expose internal details",
                            description=f"Error response contains sensitive keyword: '{keyword}'",
                            remediation="Disable debug mode in production. "
                                       "Use generic error messages. "
                                       "Log detailed errors server-side only.",
                            keyword=keyword
                        )
                        break

                # Check Server header
                if "Server" in response.headers:
                    server_header = response.headers["Server"]
                    if any(version in server_header.lower() for version in ["python", "uvicorn", "/"]):
                        self.add_warning(
                            category="Information Disclosure",
                            message=f"Server header exposes software version: {server_header}",
                            recommendation="Remove or obfuscate Server header"
                        )

            except Exception as e:
                self.log(f"Error testing information disclosure: {e}", level="ERROR")

    def check_dependency_vulnerabilities(self):
        """Check for known vulnerabilities in dependencies."""
        self.log("Checking dependency vulnerabilities...")

        try:
            # Use pip-audit or safety to check dependencies
            result = subprocess.run(
                ["pip", "list", "--format=json"],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0:
                packages = json.loads(result.stdout)

                # Known vulnerable versions (examples - update regularly)
                vulnerable_packages = {
                    "sqlalchemy": {"versions": ["<1.4.0"], "severity": "HIGH"},
                    "fastapi": {"versions": ["<0.100.0"], "severity": "MEDIUM"},
                    "pydantic": {"versions": ["<2.0.0"], "severity": "MEDIUM"},
                }

                for package in packages:
                    pkg_name = package["name"].lower()
                    pkg_version = package["version"]

                    if pkg_name in vulnerable_packages:
                        self.add_warning(
                            category="Dependency Vulnerability",
                            message=f"{pkg_name} {pkg_version} may have known vulnerabilities",
                            recommendation=f"Update {pkg_name} to latest version. "
                                         f"Run: pip install --upgrade {pkg_name}"
                        )

                self.add_passed_check("Dependency vulnerability scan completed")

        except subprocess.TimeoutExpired:
            self.log("Dependency check timed out", level="WARNING")
        except Exception as e:
            self.log(f"Error checking dependencies: {e}", level="ERROR")

    async def test_encryption_implementation(self):
        """Test encryption implementation."""
        self.log("Testing encryption implementation...")

        # Check if environment variables are set
        env_file = Path(__file__).parent.parent / ".env"
        if env_file.exists():
            with open(env_file, "r") as f:
                env_content = f.read()

            # Check for exposed secrets
            if "SECRET_KEY=\"your-secret-key" in env_content:
                self.add_vulnerability(
                    severity="CRITICAL",
                    category="Encryption",
                    title="Default SECRET_KEY in use",
                    description="Application is using default SECRET_KEY",
                    remediation="Generate strong SECRET_KEY using: openssl rand -hex 32. "
                               "Update .env file immediately."
                )

            # Check encryption is enabled
            if "ENCRYPTION_ENABLED=false" in env_content:
                self.add_vulnerability(
                    severity="HIGH",
                    category="Encryption",
                    title="Data encryption is disabled",
                    description="ENCRYPTION_ENABLED is set to false",
                    remediation="Enable encryption by setting ENCRYPTION_ENABLED=true in .env"
                )
            else:
                self.add_passed_check("Encryption enabled in configuration")

    async def run_all_tests(self):
        """Run all security tests."""
        print("\n" + "="*70)
        print("TutorMax Security Vulnerability Scanner")
        print("="*70)
        print(f"Scan started: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}")
        print(f"Target: {self.base_url}")
        print("="*70 + "\n")

        # Run all tests
        await self.test_sql_injection()
        await self.test_xss_vulnerabilities()
        await self.test_csrf_protection()
        await self.test_authentication_weaknesses()
        await self.test_security_headers()
        await self.test_information_disclosure()
        await self.test_encryption_implementation()
        self.check_dependency_vulnerabilities()

    def generate_report(self, export_json: bool = False) -> str:
        """Generate security assessment report."""
        report = []
        report.append("\n" + "="*70)
        report.append("SECURITY ASSESSMENT REPORT")
        report.append("="*70)
        report.append(f"Report generated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}")
        report.append("")

        # Summary
        critical_count = sum(1 for v in self.vulnerabilities if v["severity"] == "CRITICAL")
        high_count = sum(1 for v in self.vulnerabilities if v["severity"] == "HIGH")
        medium_count = sum(1 for v in self.vulnerabilities if v["severity"] == "MEDIUM")
        low_count = sum(1 for v in self.vulnerabilities if v["severity"] == "LOW")

        report.append("SUMMARY")
        report.append("-" * 70)
        report.append(f"Total Vulnerabilities: {len(self.vulnerabilities)}")
        report.append(f"  - Critical: {critical_count}")
        report.append(f"  - High: {high_count}")
        report.append(f"  - Medium: {medium_count}")
        report.append(f"  - Low: {low_count}")
        report.append(f"Warnings: {len(self.warnings)}")
        report.append(f"Passed Checks: {len(self.passed_checks)}")
        report.append("")

        # Risk level
        if critical_count > 0:
            risk_level = "CRITICAL - Immediate action required"
        elif high_count > 0:
            risk_level = "HIGH - Address vulnerabilities soon"
        elif medium_count > 0:
            risk_level = "MEDIUM - Review and remediate"
        else:
            risk_level = "LOW - Good security posture"

        report.append(f"Overall Risk Level: {risk_level}")
        report.append("")

        # Vulnerabilities
        if self.vulnerabilities:
            report.append("VULNERABILITIES DETECTED")
            report.append("=" * 70)
            for i, vuln in enumerate(self.vulnerabilities, 1):
                report.append(f"\n{i}. [{vuln['severity']}] {vuln['title']}")
                report.append(f"   Category: {vuln['category']}")
                report.append(f"   Description: {vuln['description']}")
                report.append(f"   Remediation: {vuln['remediation']}")

                # Add additional details
                for key, value in vuln.items():
                    if key not in ["severity", "category", "title", "description", "remediation", "timestamp"]:
                        report.append(f"   {key}: {value}")
        else:
            report.append("✓ No critical vulnerabilities detected")

        # Warnings
        if self.warnings:
            report.append("\n\nWARNINGS")
            report.append("=" * 70)
            for i, warning in enumerate(self.warnings, 1):
                report.append(f"\n{i}. {warning['category']}")
                report.append(f"   Message: {warning['message']}")
                report.append(f"   Recommendation: {warning['recommendation']}")

        # Passed checks
        report.append("\n\nPASSED SECURITY CHECKS")
        report.append("=" * 70)
        for check in self.passed_checks:
            report.append(f"✓ {check}")

        report.append("\n" + "="*70)
        report.append("END OF REPORT")
        report.append("="*70 + "\n")

        report_text = "\n".join(report)

        # Export JSON if requested
        if export_json:
            report_data = {
                "scan_timestamp": datetime.utcnow().isoformat(),
                "target": self.base_url,
                "summary": {
                    "total_vulnerabilities": len(self.vulnerabilities),
                    "critical": critical_count,
                    "high": high_count,
                    "medium": medium_count,
                    "low": low_count,
                    "warnings": len(self.warnings),
                    "passed_checks": len(self.passed_checks),
                    "risk_level": risk_level
                },
                "vulnerabilities": self.vulnerabilities,
                "warnings": self.warnings,
                "passed_checks": self.passed_checks
            }

            json_path = Path(__file__).parent.parent / "docs" / "security_scan_report.json"
            with open(json_path, "w") as f:
                json.dump(report_data, f, indent=2)

            report.append(f"\nJSON report exported to: {json_path}")

        return report_text


async def main():
    """Main entry point."""
    import argparse

    parser = argparse.ArgumentParser(description="TutorMax Security Vulnerability Scanner")
    parser.add_argument("--base-url", default="http://localhost:8000",
                       help="Base URL of the API (default: http://localhost:8000)")
    parser.add_argument("--verbose", action="store_true",
                       help="Enable verbose output")
    parser.add_argument("--export-report", action="store_true",
                       help="Export JSON report to docs/security_scan_report.json")

    args = parser.parse_args()

    scanner = VulnerabilityScanner(
        base_url=args.base_url,
        verbose=args.verbose
    )

    try:
        await scanner.run_all_tests()
        report = scanner.generate_report(export_json=args.export_report)
        print(report)

        # Exit with error code if critical vulnerabilities found
        critical_vulns = sum(1 for v in scanner.vulnerabilities if v["severity"] == "CRITICAL")
        if critical_vulns > 0:
            sys.exit(1)

    except KeyboardInterrupt:
        print("\n\nScan interrupted by user")
        sys.exit(130)
    except Exception as e:
        print(f"\n\nERROR: Scan failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
